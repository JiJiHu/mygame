<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ğŸ¦ æ„¤æ€’çš„å°é¸Ÿ</title>
    <link rel="stylesheet" href="../onepiece-theme.css">
    <!-- Matter.js ç‰©ç†å¼•æ“ -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #87CEEB 0%, #98FB98 50%, #F0E68C 100%);
            min-height: 100vh;
            overflow: hidden;
        }

        .close-btn {
            position: fixed;
            top: 15px;
            right: 15px;
            width: 40px;
            height: 40px;
            background: rgba(255, 255, 255, 0.9);
            border: 2px solid #667eea;
            border-radius: 50%;
            cursor: pointer;
            font-size: 24px;
            font-weight: bold;
            color: #667eea;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            transition: all 0.3s;
        }

        .close-btn:hover {
            background: #667eea;
            color: white;
            transform: rotate(90deg);
        }

        .game-container {
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        /* ä¸»èœå•æ ·å¼ */
        .menu-screen {
            text-align: center;
            padding: 20px;
        }

        .menu-title {
            font-size: 48px;
            color: #FF4500;
            text-shadow: 3px 3px 0 #FFD700, 6px 6px 0 #8B4513;
            margin-bottom: 20px;
            animation: bounce 1s infinite alternate;
        }

        @keyframes bounce {
            from { transform: translateY(0); }
            to { transform: translateY(-10px); }
        }

        .menu-subtitle {
            font-size: 24px;
            color: #333;
            margin-bottom: 40px;
        }

        .menu-btn {
            display: block;
            width: 200px;
            padding: 15px 30px;
            margin: 15px auto;
            font-size: 20px;
            font-weight: bold;
            color: white;
            background: linear-gradient(145deg, #FF6347, #FF4500);
            border: none;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 6px 0 #8B0000, 0 10px 20px rgba(0,0,0,0.3);
        }

        .menu-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 9px 0 #8B0000, 0 15px 25px rgba(0,0,0,0.3);
        }

        .menu-btn:active {
            transform: translateY(3px);
            box-shadow: 0 3px 0 #8B0000, 0 5px 10px rgba(0,0,0,0.3);
        }

        /* å…³å¡é€‰æ‹© */
        .level-select {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            padding: 20px;
            max-width: 600px;
        }

        .level-card {
            width: 120px;
            height: 120px;
            background: white;
            border-radius: 15px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            border: 3px solid #FF6347;
        }

        .level-card:hover {
            transform: scale(1.1);
            box-shadow: 0 8px 25px rgba(0,0,0,0.3);
        }

        .level-card.completed {
            border-color: #FFD700;
        }

        .level-number {
            font-size: 36px;
            font-weight: bold;
            color: #FF4500;
        }

        .level-stars {
            font-size: 20px;
            margin-top: 5px;
        }

        /* æ¸¸æˆç•Œé¢ */
        .game-screen {
            display: none;
            width: 100%;
            height: 100%;
            position: relative;
        }

        .game-screen.active {
            display: block;
        }

        #gameCanvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .game-ui {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            pointer-events: none;
        }

        .game-ui > * {
            pointer-events: auto;
        }

        .score-display {
            background: rgba(0,0,0,0.7);
            color: #FFD700;
            padding: 10px 20px;
            border-radius: 10px;
            font-size: 20px;
            font-weight: bold;
        }

        .birds-remaining {
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 10px 20px;
            border-radius: 10px;
            display: flex;
            gap: 8px;
        }

        .bird-icon {
            width: 25px;
            height: 25px;
            border-radius: 50%;
            border: 2px solid white;
        }

        .menu-back-btn {
            position: absolute;
            top: 10px;
            left: 10px;
            padding: 8px 16px;
            background: rgba(0,0,0,0.5);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            z-index: 100;
        }

        .restart-btn {
            background: #FF6347;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .restart-btn:hover {
            background: #FF4500;
            transform: scale(1.05);
        }

        /* æ¸¸æˆç»“æŸå¼¹çª— */
        .game-over-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .game-over-modal.active {
            display: flex;
        }

        .modal-content {
            background: white;
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            animation: popIn 0.5s ease;
            max-width: 400px;
            width: 90%;
        }

        @keyframes popIn {
            from { transform: scale(0.5); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }

        .modal-title {
            font-size: 36px;
            color: #FF4500;
            margin-bottom: 20px;
        }

        .modal-stars {
            font-size: 50px;
            margin: 20px 0;
        }

        .modal-score {
            font-size: 24px;
            color: #333;
            margin-bottom: 20px;
        }

        .modal-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .modal-btn {
            padding: 12px 30px;
            font-size: 18px;
            font-weight: bold;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .modal-btn.primary {
            background: #FFD700;
            color: #333;
        }

        .modal-btn.primary:hover {
            background: #FFC000;
            transform: scale(1.05);
        }

        .modal-btn.secondary {
            background: #667eea;
            color: white;
        }

        .modal-btn.secondary:hover {
            background: #5568d3;
            transform: scale(1.05);
        }

        /* éšè—/æ˜¾ç¤ºæ§åˆ¶ */
        .screen {
            display: none;
        }

        .screen.active {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 100%;
        }

        /* æç¤ºæ–‡å­— */
        .hint-text {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 16px;
            pointer-events: none;
        }

        /* å“åº”å¼ */
        @media (max-width: 600px) {
            .menu-title {
                font-size: 32px;
            }

            .level-card {
                width: 90px;
                height: 90px;
            }

            .level-number {
                font-size: 28px;
            }

            .game-ui {
                flex-wrap: wrap;
                gap: 10px;
            }

            .score-display, .birds-remaining {
                font-size: 14px;
                padding: 8px 12px;
            }
        }

        /* ç§»åŠ¨ç«¯è§¦æ‘¸ä¼˜åŒ– */
        @media (pointer: coarse) {
            #gameCanvas {
                touch-action: none;
                -webkit-touch-callout: none;
                -webkit-user-select: none;
                user-select: none;
            }

            body {
                overscroll-behavior: none;
            }
        }

        /* æç¤ºæ–‡å­—ç§»åŠ¨ç«¯ä¼˜åŒ– */
        .hint-text {
            text-align: center;
            padding: 10px;
            font-size: 14px;
            pointer-events: none;
        }

        @media (max-width: 600px) {
            .hint-text {
                font-size: 12px;
                padding: 5px;
            }
        }

        /* æ¨¡æ€æ¡†ç§»åŠ¨ç«¯é€‚é… */
        .modal-content {
            max-width: 90%;
            max-height: 80%;
            overflow-y: auto;
        }

        @media (max-width: 600px) {
            .modal-content {
                padding: 20px;
            }

            .modal-btn {
                padding: 12px 24px;
                font-size: 16px;
            }
        }
    </style>
</head>
<body>
    <button class="close-btn" onclick="goBackHome()" title="è¿”å›ä¸»é¡µ">Ã—</button>

    <!-- ä¸»èœå• -->
    <div id="menuScreen" class="screen active">
        <div class="menu-screen">
            <h1 class="menu-title">ğŸ¦ æ„¤æ€’çš„å°é¸Ÿ</h1>
            <p class="menu-subtitle">æ¶ˆç­æ‰€æœ‰å°çŒªï¼Œè·å¾—ä¸‰æ˜Ÿè¯„ä»·ï¼</p>
            <button class="menu-btn" onclick="showLevelSelect()">å¼€å§‹æ¸¸æˆ</button>
            <button class="menu-btn" onclick="showHowToPlay()">æ¸¸æˆè¯´æ˜</button>
        </div>
    </div>

    <!-- å…³å¡é€‰æ‹© -->
    <div id="levelScreen" class="screen">
        <h2 style="color: #333; margin-bottom: 30px; font-size: 28px;">é€‰æ‹©å…³å¡</h2>
        <div class="level-select" id="levelGrid"></div>
    </div>

    <!-- æ¸¸æˆç•Œé¢ -->
    <div id="gameScreen" class="screen">
        <canvas id="gameCanvas"></canvas>
        <div class="game-ui">
            <button class="menu-back-btn" onclick="backToLevelSelect()">â† è¿”å›</button>
            <div class="score-display">å¾—åˆ†: <span id="scoreValue">0</span></div>
            <div class="birds-remaining" id="birdsDisplay"></div>
            <button class="restart-btn" onclick="restartLevel()">ğŸ”„ é‡æ–°å¼€å§‹</button>
        </div>
        <div class="hint-text" id="hintText">æ‹–æ‹½å°é¸Ÿå‘å°„ï¼Œæ¶ˆç­æ‰€æœ‰å°çŒªï¼</div>
    </div>

    <!-- æ¸¸æˆç»“æŸå¼¹çª— -->
    <div class="game-over-modal" id="gameOverModal">
        <div class="modal-content">
            <h2 class="modal-title" id="modalTitle">ğŸ‰ è¿‡å…³å•¦ï¼</h2>
            <div class="modal-stars" id="modalStars">â­â­â­</div>
            <p class="modal-score">å¾—åˆ†: <span id="finalScore">0</span></p>
            <p style="color: #666; margin-bottom: 20px;" id="modalMessage"></p>
            <div class="modal-buttons">
                <button class="modal-btn secondary" onclick="backToLevelSelect()">è¿”å›å…³å¡</button>
                <button class="modal-btn primary" onclick="restartLevel()">å†æ¥ä¸€å±€</button>
                <button class="modal-btn primary" onclick="nextLevel()" id="nextLevelBtn">ä¸‹ä¸€å…³</button>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <script>
        // ==================== æ¸¸æˆé…ç½® ====================
        const CONFIG = {
            // ç‰©ç†å¼•æ“
            gravity: { x: 0, y: 1 },
            enableSleeping: true,

            // å¼¹å¼“å‚æ•°
            slingshotX: 150,
            slingshotY: 450,
            maxPullDistance: 120,
            launchForceMultiplier: 0.045,

            // æ¸¸æˆå‚æ•°
            birdRadius: 15,
            pigRadius: 18,
            groundY: 550,
            canvasWidth: 900,
            canvasHeight: 600,

            // ä¼¤å®³é˜ˆå€¼
            damageThreshold: 3,
            damageMultiplier: 8,
            pigDeathThreshold: 15,
            blockDestructionThreshold: 25
        };

        // ç¢°æ’ç±»åˆ«
        const CATEGORY = {
            GROUND: 0x0001,
            BIRD: 0x0002,
            PIG: 0x0004,
            BLOCK: 0x0008,
            EGG: 0x0010,
            DEBRIS: 0x0020
        };

        // å°é¸Ÿç±»å‹
        const BIRD_TYPES = {
            red: {
                name: 'çº¢è‰²å°é¸Ÿ',
                color: '#FF0000',
                borderColor: '#8B0000',
                radius: 15,
                ability: null,
                score: 5000
            },
            yellow: {
                name: 'é»„è‰²å°é¸Ÿ',
                color: '#FFD700',
                borderColor: '#B8860B',
                radius: 15,
                ability: 'speedBoost',
                abilityParam: 2.5,
                score: 10000
            },
            blue: {
                name: 'è“è‰²å°é¸Ÿ',
                color: '#00BFFF',
                borderColor: '#006400',
                radius: 12,
                ability: 'split',
                abilityParam: 3,
                score: 15000
            },
            white: {
                name: 'ç™½è‰²å°é¸Ÿ',
                color: '#FFFFFF',
                borderColor: '#A9A9A9',
                radius: 15,
                ability: 'eggBomb',
                score: 15000
            },
            black: {
                name: 'é»‘è‰²å°é¸Ÿ',
                color: '#333333',
                borderColor: '#000000',
                radius: 18,
                ability: 'explode',
                abilityParam: 80,
                score: 20000
            }
        };

        // ææ–™ç±»å‹
        const MATERIALS = {
            wood: {
                name: 'æœ¨å¤´',
                color: '#8B4513',
                borderColor: '#5D3A1A',
                health: 80,
                mass: 1.5,
                friction: 0.5,
                restitution: 0.3,
                score: 100
            },
            glass: {
                name: 'ç»ç’ƒ',
                color: '#87CEEB',
                borderColor: '#4682B4',
                health: 30,
                mass: 0.5,
                friction: 0.3,
                restitution: 0.2,
                score: 50
            },
            stone: {
                name: 'çŸ³å¤´',
                color: '#808080',
                borderColor: '#404040',
                health: 200,
                mass: 3.0,
                friction: 0.8,
                restitution: 0.1,
                score: 150
            }
        };

        // çŒªç±»å‹
        const PIG_TYPES = {
            small: { name: 'å°çŒª', color: '#90EE90', borderColor: '#228B22', radius: 15, health: 50, score: 500 },
            medium: { name: 'ä¸­çŒª', color: '#32CD32', borderColor: '#006400', radius: 20, health: 80, score: 1000 },
            large: { name: 'å¤§çŒª', color: '#228B22', borderColor: '#006400', radius: 28, health: 120, score: 2000 }
        };

        // å…³å¡æ•°æ®
        const LEVELS = [
            {
                id: 1,
                name: 'ç¬¬ä¸€å…³',
                birds: ['red', 'red', 'yellow', 'blue'],
                pigs: [
                    { type: 'small', x: 600, y: 480 },
                    { type: 'small', x: 650, y: 480 }
                ],
                structures: [
                    { type: 'wood', shape: 'rect', x: 600, y: 520, w: 15, h: 60 },
                    { type: 'wood', shape: 'rect', x: 650, y: 520, w: 15, h: 60 },
                    { type: 'wood', shape: 'rect', x: 625, y: 555, w: 80, h: 15 },
                    { type: 'glass', shape: 'rect', x: 625, y: 500, w: 15, h: 40 }
                ],
                starThresholds: { oneStar: 3000, twoStars: 8000, threeStars: 12000 }
            },
            {
                id: 2,
                name: 'ç¬¬äºŒå…³',
                birds: ['red', 'yellow', 'blue', 'white', 'black'],
                pigs: [
                    { type: 'small', x: 550, y: 480 },
                    { type: 'medium', x: 650, y: 450 },
                    { type: 'small', x: 700, y: 480 }
                ],
                structures: [
                    // åº•å±‚
                    { type: 'stone', shape: 'rect', x: 550, y: 520, w: 15, h: 60 },
                    { type: 'stone', shape: 'rect', x: 700, y: 520, w: 15, h: 60 },
                    { type: 'wood', shape: 'rect', x: 625, y: 555, w: 180, h: 15 },
                    // ä¸­å±‚
                    { type: 'glass', shape: 'rect', x: 580, y: 490, w: 12, h: 50 },
                    { type: 'glass', shape: 'rect', x: 670, y: 490, w: 12, h: 50 },
                    { type: 'wood', shape: 'rect', x: 625, y: 470, w: 120, h: 12 },
                    // é¡¶å±‚
                    { type: 'wood', shape: 'rect', x: 650, y: 440, w: 15, h: 40 }
                ],
                starThresholds: { oneStar: 5000, twoStars: 12000, threeStars: 20000 }
            },
            {
                id: 3,
                name: 'ç¬¬ä¸‰å…³',
                birds: ['red', 'yellow', 'yellow', 'blue', 'white', 'black'],
                pigs: [
                    { type: 'small', x: 500, y: 480 },
                    { type: 'medium', x: 580, y: 420 },
                    { type: 'small', x: 650, y: 480 },
                    { type: 'large', x: 720, y: 450 }
                ],
                structures: [
                    // å·¦è¾¹å¡”
                    { type: 'wood', shape: 'rect', x: 500, y: 520, w: 15, h: 60 },
                    { type: 'wood', shape: 'rect', x: 540, y: 520, w: 15, h: 60 },
                    { type: 'glass', shape: 'rect', x: 520, y: 555, w: 60, h: 15 },
                    // ä¸­é—´å¡”
                    { type: 'stone', shape: 'rect', x: 580, y: 470, w: 18, h: 80 },
                    { type: 'stone', shape: 'rect', x: 620, y: 470, w: 18, h: 80 },
                    { type: 'wood', shape: 'rect', x: 600, y: 430, w: 80, h: 15 },
                    // å³è¾¹å¡”
                    { type: 'wood', shape: 'rect', x: 650, y: 520, w: 15, h: 60 },
                    { type: 'wood', shape: 'rect', x: 690, y: 520, w: 15, h: 60 },
                    { type: 'glass', shape: 'rect', x: 670, y: 555, w: 60, h: 15 },
                    // é¡¶å±‚
                    { type: 'glass', shape: 'rect', x: 720, y: 490, w: 15, h: 60 },
                    { type: 'glass', shape: 'rect', x: 760, y: 490, w: 15, h: 60 },
                    { type: 'stone', shape: 'rect', x: 740, y: 455, w: 70, h: 15 }
                ],
                starThresholds: { oneStar: 8000, twoStars: 18000, threeStars: 30000 }
            }
        ];

        // ==================== æ¸¸æˆçŠ¶æ€ ====================
        let gameState = 'menu';
        let currentLevel = 0;
        let score = 0;
        let usedBirds = 0;
        let pigsRemaining = 0;
        let birdsQueue = [];
        let currentBird = null;
        let pigs = [];
        let blocks = [];
        let debris = [];
        let isBirdFlying = false;
        let canActivateAbility = false;
        let levelStars = [0, 0, 0];
        let mousePos = { x: 0, y: 0 };

        // Matter.js å˜é‡
        let engine, render, runner, world;
        let slingshot, slingConstraint;
        let ground;
        let mouseConstraint;

        // ==================== åˆå§‹åŒ– ====================
        function init() {
            // æ£€æŸ¥ Matter.js æ˜¯å¦åŠ è½½
            if (typeof Matter === 'undefined') {
                alert('âŒ é”™è¯¯ï¼šMatter.js ç‰©ç†å¼•æ“æœªåŠ è½½ï¼\n\nè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥ï¼Œæˆ–æ‰‹åŠ¨ä¸‹è½½å¹¶å¼•ç”¨æœ¬åœ°çš„ Matter.js æ–‡ä»¶ã€‚');
                return;
            }

            // åˆå§‹åŒ– Matter.js
            const { Engine, Render, Runner, World, Bodies, Body, Composite, Events, Mouse, MouseConstraint, Vector } = Matter;

            engine = Engine.create({
                enableSleeping: CONFIG.enableSleeping,
                gravity: CONFIG.gravity
            });
            world = engine.world;

            // åˆ›å»ºæ¸²æŸ“å™¨
            const canvas = document.getElementById('gameCanvas');
            render = Render.create({
                canvas: canvas,
                engine: engine,
                options: {
                    width: CONFIG.canvasWidth,
                    height: CONFIG.canvasHeight,
                    wireframes: false,
                    background: 'transparent'
                }
            });

            // åˆ›å»ºé¼ æ ‡æ§åˆ¶
            const mouse = Mouse.create(canvas);
            mouseConstraint = MouseConstraint.create(engine, {
                mouse: mouse,
                constraint: {
                    stiffness: 0.2,
                    render: { visible: false }
                }
            });

            // å°†é¼ æ ‡çº¦æŸæ·»åŠ åˆ°ä¸–ç•Œä¸­ï¼ˆå…³é”®æ­¥éª¤ï¼ï¼‰
            Composite.add(world, mouseConstraint);

            // ç¡®ä¿ canvas å¯ä»¥æ¥æ”¶é¼ æ ‡äº‹ä»¶
            canvas.style.cursor = 'pointer';

            // ç§»åŠ¨ç«¯ï¼šæ·»åŠ è§¦æ‘¸äº‹ä»¶æ”¯æŒ
            // Matter.js çš„ Mouse ä¼šè‡ªåŠ¨å¤„ç†è§¦æ‘¸äº‹ä»¶
            // ä½†æˆ‘ä»¬éœ€è¦ç¡®ä¿è§¦æ‘¸äº‹ä»¶èƒ½æ­£ç¡®ä¼ é€’

            // é¼ æ ‡ç§»åŠ¨äº‹ä»¶
            canvas.addEventListener('mousemove', (e) => {
                const rect = canvas.getBoundingClientRect();
                const scaleX = CONFIG.canvasWidth / rect.width;
                const scaleY = CONFIG.canvasHeight / rect.height;
                mousePos.x = (e.clientX - rect.left) * scaleX;
                mousePos.y = (e.clientY - rect.top) * scaleY;
            });

            // è§¦æ‘¸ç§»åŠ¨äº‹ä»¶ï¼ˆç§»åŠ¨ç«¯ï¼‰
            canvas.addEventListener('touchmove', (e) => {
                e.preventDefault();
                const touch = e.touches[0];
                const rect = canvas.getBoundingClientRect();
                const scaleX = CONFIG.canvasWidth / rect.width;
                const scaleY = CONFIG.canvasHeight / rect.height;
                mousePos.x = (touch.clientX - rect.left) * scaleX;
                mousePos.y = (touch.clientY - rect.top) * scaleY;
            }, { passive: false });

            // é¼ æ ‡é‡Šæ”¾äº‹ä»¶ï¼ˆå‘å°„å°é¸Ÿï¼‰
            canvas.addEventListener('mouseup', handleMouseUp);
            canvas.addEventListener('mousedown', handleMouseDown);
            
            // è§¦æ‘¸äº‹ä»¶
            canvas.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const touch = e.touches[0];
                const rect = canvas.getBoundingClientRect();
                const scaleX = CONFIG.canvasWidth / rect.width;
                const scaleY = CONFIG.canvasHeight / rect.height;
                mousePos.x = (touch.clientX - rect.left) * scaleX;
                mousePos.y = (touch.clientY - rect.top) * scaleY;
                handleMouseDown(e);
            }, { passive: false });

            canvas.addEventListener('touchmove', (e) => {
                e.preventDefault();
                const touch = e.touches[0];
                const rect = canvas.getBoundingClientRect();
                const scaleX = CONFIG.canvasWidth / rect.width;
                const scaleY = CONFIG.canvasHeight / rect.height;
                mousePos.x = (touch.clientX - rect.left) * scaleX;
                mousePos.y = (touch.clientY - rect.top) * scaleY;
            }, { passive: false });

            canvas.addEventListener('touchend', (e) => {
                e.preventDefault();
                handleMouseUp(e);
            }, { passive: false });
            // ç¢°æ’äº‹ä»¶
            Events.on(engine, 'collisionStart', handleCollision);

            // æ¸²æŸ“å‰äº‹ä»¶ï¼ˆè‡ªå®šä¹‰ç»˜åˆ¶ï¼‰
            Events.on(render, 'beforeRender', beforeRender);
            Events.on(render, 'afterRender', afterRender);

            // å¯åŠ¨å¼•æ“å’Œæ¸²æŸ“å™¨
            runner = Runner.create();
            Runner.run(runner, engine);
            Render.run(render);

            // ç§»åŠ¨ç«¯è‡ªé€‚åº”
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);

            // åŠ è½½å­˜æ¡£
            loadProgress();

            // æ˜¾ç¤ºä¸»èœå•
            showMenu();
        }

        // ç§»åŠ¨ç«¯è‡ªé€‚åº”canvaså¤§å°
        function resizeCanvas() {
            const canvas = document.getElementById('gameCanvas');
            const gameScreen = document.getElementById('gameScreen');

            if (window.innerWidth <= 768) {
                // ç§»åŠ¨ç«¯ï¼šè°ƒæ•´canvaså¤§å°ä»¥é€‚åº”å±å¹•
                const screenWidth = window.innerWidth;
                const screenHeight = window.innerHeight - 100; // ç•™å‡ºUIç©ºé—´

                const desiredRatio = CONFIG.canvasWidth / CONFIG.canvasHeight;
                const actualRatio = screenWidth / screenHeight;

                if (actualRatio > desiredRatio) {
                    // å±å¹•æ›´å®½ï¼Œä»¥é«˜åº¦ä¸ºå‡†
                    canvas.style.height = screenHeight + 'px';
                    canvas.style.width = (screenHeight * desiredRatio) + 'px';
                } else {
                    // å±å¹•æ›´é«˜ï¼Œä»¥å®½åº¦ä¸ºå‡†
                    canvas.style.width = screenWidth + 'px';
                    canvas.style.height = (screenWidth / desiredRatio) + 'px';
                }
            } else {
                // æ¡Œé¢ç«¯ï¼šä¿æŒåŸå§‹æ¯”ä¾‹
                canvas.style.width = CONFIG.canvasWidth + 'px';
                canvas.style.height = CONFIG.canvasHeight + 'px';
            }

            // é‡æ–°åˆ›å»º mouse å’Œ mouseConstraint ä»¥åŒ¹é…æ–°çš„ canvas å°ºå¯¸
            // åªåœ¨éæ¸¸æˆçŠ¶æ€ä¸‹é‡æ–°åˆ›å»ºï¼Œé¿å…å½±å“æ­£åœ¨è¿›è¡Œçš„æ¸¸æˆ
            if (world && mouseConstraint && gameState !== 'playing') {
                const { Mouse, MouseConstraint, Composite } = Matter;
                Composite.remove(world, mouseConstraint);

                const mouse = Mouse.create(canvas);
                mouseConstraint = MouseConstraint.create(engine, {
                    mouse: mouse,
                    constraint: {
                        stiffness: 0.2,
                        render: { visible: false }
                    }
                });
                Composite.add(world, mouseConstraint);

                // é‡æ–°ç»‘å®šäº‹ä»¶ç›‘å¬å™¨
                canvas.addEventListener('mousedown', handleMouseDown);
                canvas.addEventListener('mouseup', handleMouseUp);
                canvas.addEventListener('mousemove', (e) => {
                    const rect = canvas.getBoundingClientRect();
                    const scaleX = CONFIG.canvasWidth / rect.width;
                    const scaleY = CONFIG.canvasHeight / rect.height;
                    mousePos.x = (e.clientX - rect.left) * scaleX;
                    mousePos.y = (e.clientY - rect.top) * scaleY;
                });
                canvas.addEventListener('touchstart', (e) => {
                    // ä¸é˜»æ­¢é»˜è®¤äº‹ä»¶ï¼Œå…è®¸æ‹–åŠ¨
                }, { passive: false });
                canvas.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    const rect = canvas.getBoundingClientRect();
                    const scaleX = CONFIG.canvasWidth / rect.width;
                    const scaleY = CONFIG.canvasHeight / rect.height;
                    mousePos.x = (touch.clientX - rect.left) * scaleX;
                    mousePos.y = (touch.clientY - rect.top) * scaleY;
                }, { passive: false });
                canvas.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    handleMouseUp(e);
                }, { passive: false });
            }
        }

        // ==================== åœºæ™¯ç®¡ç† ====================
        function showScreen(screenId) {
            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
            document.getElementById(screenId).classList.add('active');
        }

        function showMenu() {
            gameState = 'menu';
            showScreen('menuScreen');
        }

        function showLevelSelect() {
            gameState = 'levelSelect';
            renderLevelGrid();
            showScreen('levelScreen');
        }

        function showGame() {
            gameState = 'playing';
            showScreen('gameScreen');
            document.getElementById('hintText').style.display = 'block';
            setTimeout(() => {
                document.getElementById('hintText').style.display = 'none';
            }, 3000);
        }

        function showHowToPlay() {
            alert('ğŸ® æ¸¸æˆè¯´æ˜ï¼š\n\n1. æ‹–æ‹½å°é¸Ÿå‘åæ‹‰åŠ¨å¼¹å¼“\n2. æ¾å¼€å‘å°„å°é¸Ÿ\n3. æ¶ˆç­æ‰€æœ‰å°çŒªè¿‡å…³\n4. ä½¿ç”¨è¶Šå°‘å°é¸Ÿï¼Œå¾—åˆ†è¶Šé«˜\n5. ç‚¹å‡»é£è¡Œä¸­çš„å°é¸Ÿå¯æ¿€æ´»ç‰¹æ®Šèƒ½åŠ›\n\nğŸ¦ å°é¸Ÿèƒ½åŠ›ï¼š\nâ€¢ çº¢è‰²ï¼šæ™®é€šå°é¸Ÿ\nâ€¢ é»„è‰²ï¼šç‚¹å‡»åŠ é€Ÿå†²åˆº\nâ€¢ è“è‰²ï¼šç‚¹å‡»åˆ†è£‚æˆä¸‰åª\nâ€¢ ç™½è‰²ï¼šç‚¹å‡»ä¸‹è›‹ç‚¸å¼¹\nâ€¢ é»‘è‰²ï¼šç‚¹å‡»çˆ†ç‚¸');
        }

        // ==================== å…³å¡ç³»ç»Ÿ ====================
        function renderLevelGrid() {
            const grid = document.getElementById('levelGrid');
            grid.innerHTML = '';

            LEVELS.forEach((level, index) => {
                const card = document.createElement('div');
                card.className = 'level-card' + (levelStars[index] > 0 ? ' completed' : '');
                card.onclick = () => startLevel(index);

                const stars = 'â­'.repeat(levelStars[index]);

                card.innerHTML = `
                    <div class="level-number">${level.id}</div>
                    <div class="level-stars">${stars}</div>
                `;
                grid.appendChild(card);
            });
        }

        function startLevel(levelIndex) {
            currentLevel = levelIndex;
            initLevel(LEVELS[levelIndex]);
            showGame();
        }

        function initLevel(levelData) {
            const { Engine, World, Bodies, Composite, Constraint, Body } = Matter;

            // æ¸…é™¤ä¸–ç•Œ
            Composite.clear(world, false);

            // é‡ç½®æ¸¸æˆçŠ¶æ€
            score = 0;
            usedBirds = 0;
            isBirdFlying = false;
            canActivateAbility = false;
            pigs = [];
            blocks = [];
            debris = [];
            birdsQueue = [...levelData.birds];

            // åˆ›å»ºåœ°é¢
            ground = Bodies.rectangle(
                CONFIG.canvasWidth / 2,
                CONFIG.groundY + 25,
                CONFIG.canvasWidth,
                50,
                {
                    isStatic: true,
                    label: 'ground',
                    render: { fillStyle: '#228B22' },
                    collisionFilter: { category: CATEGORY.GROUND }
                }
            );
            Composite.add(world, ground);

            // åˆ›å»ºå°çŒª
            levelData.pigs.forEach(pigData => {
                const pigType = PIG_TYPES[pigData.type];
                const pig = Bodies.circle(pigData.x, pigData.y, pigType.radius, {
                    label: 'pig',
                    render: { fillStyle: pigType.color },
                    collisionFilter: {
                        category: CATEGORY.PIG,
                        mask: CATEGORY.GROUND | CATEGORY.BIRD | CATEGORY.BLOCK | CATEGORY.EGG | CATEGORY.DEBRIS
                    },
                    restitution: 0.3,
                    friction: 0.5
                });
                pig.health = pigType.health;
                pig.pigType = pigType;
                pig.maxHealth = pigType.health;
                pigs.push(pig);
                Composite.add(world, pig);
            });
            pigsRemaining = pigs.length;

            // åˆ›å»ºå»ºç­‘ç‰©
            levelData.structures.forEach(blockData => {
                const material = MATERIALS[blockData.type];
                let block;

                if (blockData.shape === 'rect') {
                    block = Bodies.rectangle(
                        blockData.x,
                        blockData.y,
                        blockData.w,
                        blockData.h,
                        {
                            label: 'block',
                            render: { fillStyle: material.color },
                            collisionFilter: {
                                category: CATEGORY.BLOCK,
                                mask: CATEGORY.GROUND | CATEGORY.BIRD | CATEGORY.BLOCK | CATEGORY.PIG | CATEGORY.EGG | CATEGORY.DEBRIS
                            },
                            mass: material.mass,
                            friction: material.friction,
                            restitution: material.restitution
                        }
                    );
                } else {
                    block = Bodies.circle(blockData.x, blockData.y, blockData.w / 2, {
                        label: 'block',
                        render: { fillStyle: material.color },
                        collisionFilter: {
                            category: CATEGORY.BLOCK,
                            mask: CATEGORY.GROUND | CATEGORY.BIRD | CATEGORY.BLOCK | CATEGORY.PIG | CATEGORY.EGG | CATEGORY.DEBRIS
                        },
                        mass: material.mass,
                        friction: material.friction,
                        restitution: material.restitution
                    });
                }

                block.health = material.health;
                block.maxHealth = material.health;
                block.material = material;
                blocks.push(block);
                Composite.add(world, block);
            });


            // åŠ è½½ç¬¬ä¸€åªå°é¸Ÿ
            loadNextBird();

            // æ›´æ–°UI
            updateUI();
        }

        function loadNextBird() {
            const { World, Bodies, Constraint, Body, Composite } = Matter;

            if (birdsQueue.length === 0) {
                // æ£€æŸ¥æ¸¸æˆæ˜¯å¦ç»“æŸ
                setTimeout(checkGameEnd, 2000);
                return;
            }

            const birdType = birdsQueue.shift();
            const birdData = BIRD_TYPES[birdType];

            // åˆ›å»ºå°é¸Ÿ
            currentBird = Bodies.circle(
                CONFIG.slingshotX,
                CONFIG.slingshotY,
                birdData.radius,
                {
                    label: 'bird',
                    render: {
                        fillStyle: birdData.color,
                        strokeStyle: birdData.borderColor || '#000000',
                        lineWidth: 2
                    },
                    collisionFilter: {
                        category: CATEGORY.BIRD,
                        mask: 0x0001 | CATEGORY.GROUND | CATEGORY.PIG | CATEGORY.BLOCK | CATEGORY.EGG | CATEGORY.DEBRIS
                    },
                    restitution: 0.5,
                    friction: 0.5,
                    density: 0.004,
                    frictionAir: 0.001
                }
            );

            currentBird.birdType = birdType;
            currentBird.birdData = birdData;
            currentBird.originalRadius = birdData.radius;
            currentBird.canActivate = true;
            // æ ‡è®°ä¸ºå¯æ‹–åŠ¨ï¼ˆåœ¨å¼¹å¼“ä¸Šï¼‰
            currentBird.isDraggable = true;
            currentBird.isStatic = false;

            Composite.add(world, currentBird);

            // åˆ›å»ºä¿æŒçº¦æŸï¼Œè®©å°é¸Ÿä¿æŒåœ¨å¼¹å¼“ä¸Šç›´åˆ°è¢«æ‹–åŠ¨
            const holdingConstraint = Constraint.create({
                pointA: { x: CONFIG.slingshotX, y: CONFIG.slingshotY },
                bodyB: currentBird,
                stiffness: 1,
                length: 0,
                render: { visible: false }
            });
            Composite.add(world, holdingConstraint);
            currentBird.holdingConstraint = holdingConstraint;

            // ä¸ç«‹å³åˆ›å»ºå¼¹å¼“çº¦æŸ - ç­‰å¾…æ‹–åŠ¨æ—¶åˆ›å»º
            slingConstraint = null;

            isBirdFlying = false;
            canActivateAbility = false;
        }

        // ==================== å¼¹å¼“æ§åˆ¶ ====================
        // æ‹–åŠ¨çŠ¶æ€
        let isDraggingBird = false;
        let isMousePressed = false;
        
        function handleMouseDown(e) {
            isMousePressed = true;
            
            if (!currentBird || isBirdFlying) return;
            
            const { Vector, Body, Constraint, Composite } = Matter;
            
            // è·å–ç‚¹å‡»ä½ç½®ï¼ˆæ”¯æŒé¼ æ ‡å’Œè§¦æ‘¸ï¼‰
            let clientX, clientY;
            if (e.touches && e.touches.length > 0) {
                clientX = e.touches[0].clientX;
                clientY = e.touches[0].clientY;
            } else if (e.changedTouches && e.changedTouches.length > 0) {
                clientX = e.changedTouches[0].clientX;
                clientY = e.changedTouches[0].clientY;
            } else {
                clientX = e.clientX;
                clientY = e.clientY;
            }
            
            // è®¡ç®—å®é™…çš„é¼ æ ‡/è§¦æ‘¸ä½ç½®
            const rect = canvas.getBoundingClientRect();
            const scaleX = CONFIG.canvasWidth / rect.width;
            const scaleY = CONFIG.canvasHeight / rect.height;
            const clickPos = {
                x: (clientX - rect.left) * scaleX,
                y: (clientY - rect.top) * scaleY
            };
            
            // æ£€æŸ¥æ˜¯å¦ç‚¹å‡»åœ¨å°é¸Ÿé™„è¿‘
            const dist = Vector.magnitude(Vector.sub(clickPos, currentBird.position));
            if (dist > currentBird.birdData.radius + 20) return;
            
            // å¦‚æœå°é¸Ÿåœ¨å¼¹å¼“ä½ç½®é™„è¿‘ï¼ˆå…è®¸æ‹–åŠ¨ï¼‰
            const distToSlingshot = Vector.magnitude(Vector.sub(currentBird.position, { x: CONFIG.slingshotX, y: CONFIG.slingshotY }));
            if (distToSlingshot > CONFIG.maxPullDistance * 2.5) return;
            
            // å¼€å§‹æ‹–åŠ¨
            isDraggingBird = true;
            
            // åˆ›å»ºå¼¹å¼“çº¦æŸï¼ˆå¦‚æœæ²¡æœ‰ï¼‰
            if (currentBird.holdingConstraint) { Composite.remove(world, currentBird.holdingConstraint); currentBird.holdingConstraint = null; }
            if (!slingConstraint) {
                slingConstraint = Constraint.create({
                    pointA: { x: CONFIG.slingshotX, y: CONFIG.slingshotY },
                    bodyB: currentBird,
                    stiffness: 0.05,
                    damping: 0.01,
                    length: 0,
                    render: { visible: false }
                });
                Composite.add(world, slingConstraint);
            }
        }

        function handleMouseMove(e) {
            // å¤„ç†è§¦æ‘¸ç§»åŠ¨
            if (e.touches) {
                const touch = e.touches[0];
                const rect = document.getElementById('gameCanvas').getBoundingClientRect();
                const scaleX = CONFIG.canvasWidth / rect.width;
                const scaleY = CONFIG.canvasHeight / rect.height;
                mousePos.x = (touch.clientX - rect.left) * scaleX;
                mousePos.y = (touch.clientY - rect.top) * scaleY;
            }
        }

        function handleMouseUp(e) {
            isMousePressed = false;
            
            // å¤„ç†é£è¡Œä¸­å°é¸Ÿçš„ç‰¹æ®Šèƒ½åŠ›æ¿€æ´»
            if (currentBird && isBirdFlying && canActivateAbility && currentBird.canActivate) {
                activateBirdAbility();
                return;
            }
            
            if (!currentBird || !isDraggingBird || !slingConstraint) return;
            
            isDraggingBird = false;
            const { World, Composite, Vector, Body } = Matter;

            // è®¡ç®—å‘å°„å‘é‡
            const pullVector = Vector.sub({ x: CONFIG.slingshotX, y: CONFIG.slingshotY }, currentBird.position);
            const pullDistance = Vector.magnitude(pullVector);

            if (pullDistance < 25) {
                // æ‹‰è·ä¸å¤Ÿï¼Œé‡ç½®å°é¸Ÿä½ç½®
                Body.setPosition(currentBird, { x: CONFIG.slingshotX, y: CONFIG.slingshotY });
                Body.setVelocity(currentBird, { x: 0, y: 0 });
                Composite.remove(world, slingConstraint);
                slingConstraint = null;
                return;
            }

            // ç§»é™¤å¼¹å¼“çº¦æŸ
            Composite.remove(world, slingConstraint);
            slingConstraint = null;

            // åº”ç”¨å‘å°„åŠ›
            const clampedDistance = Math.min(pullDistance, CONFIG.maxPullDistance);
            const force = Vector.mult(Vector.normalise(pullVector), clampedDistance * CONFIG.launchForceMultiplier);
            Body.applyForce(currentBird, currentBird.position, force);

            isBirdFlying = true;
            canActivateAbility = true;
            currentBird.isDraggable = false;
            usedBirds++;

            // å»¶è¿Ÿæ£€æŸ¥å°é¸ŸçŠ¶æ€
            setTimeout(checkBirdStatus, 500);
        }
        
        function activateBirdAbility() {
            if (!currentBird || !currentBird.canActivate) return;
            
            const { World, Bodies, Composite, Body, Vector } = Matter;
            const birdType = currentBird.birdType;

            currentBird.canActivate = false;
            canActivateAbility = false;

            switch (birdType) {
                case 'yellow':
                    // åŠ é€Ÿå†²åˆº
                    const velocity = currentBird.velocity;
                    Body.setVelocity(currentBird, {
                        x: velocity.x * currentBird.birdData.abilityParam,
                        y: velocity.y * currentBird.birdData.abilityParam
                    });
                    break;

                case 'blue':
                    // åˆ†è£‚æˆä¸‰åª
                    const baseVel = currentBird.velocity;
                    const angle = Math.atan2(baseVel.y, baseVel.x);
                    const speed = Vector.magnitude(baseVel);

                    for (let i = -1; i <= 1; i++) {
                        if (i === 0) continue;
                        const newAngle = angle + (i * 0.5);
                        const miniBird = Bodies.circle(
                            currentBird.position.x,
                            currentBird.position.y,
                            8,
                            {
                                label: 'bird',
                                render: { fillStyle: currentBird.birdData.color },
                                collisionFilter: {
                                    category: CATEGORY.BIRD,
                                    mask: CATEGORY.GROUND | CATEGORY.PIG | CATEGORY.BLOCK | CATEGORY.EGG | CATEGORY.DEBRIS
                                },
                                density: 0.002
                            }
                        );
                        Body.setVelocity(miniBird, {
                            x: Math.cos(newAngle) * speed,
                            y: Math.sin(newAngle) * speed
                        });
                        Composite.add(world, miniBird);
                    }
                    Composite.remove(world, currentBird);
                    currentBird = null;
                    break;

                case 'white':
                    // ä¸‹è›‹ç‚¸å¼¹
                    const egg = Bodies.circle(
                        currentBird.position.x,
                        currentBird.position.y + 20,
                        10,
                        {
                            label: 'egg',
                            render: { fillStyle: '#FFD700' },
                            collisionFilter: {
                                category: CATEGORY.EGG,
                                mask: CATEGORY.GROUND | CATEGORY.BLOCK | CATEGORY.PIG
                            },
                            density: 0.008
                        }
                    );
                    Body.setVelocity(egg, {
                        x: currentBird.velocity.x,
                        y: 5
                    });
                    Composite.add(world, egg);
                    break;

                case 'black':
                    // çˆ†ç‚¸
                    const explosionPos = currentBird.position;
                    const explosionRadius = currentBird.birdData.abilityParam;

                    const allBodies = Composite.allBodies(world);
                    allBodies.forEach(body => {
                        if (body.isStatic) return;
                        const dist = Vector.magnitude(Vector.sub(body.position, explosionPos));
                        if (dist < explosionRadius) {
                            const forceMag = (explosionRadius - dist) * 0.5;
                            const dir = Vector.normalise(Vector.sub(body.position, explosionPos));
                            Body.applyForce(body, body.position, Vector.mult(dir, forceMag));
                            if (body.label === 'pig') {
                                body.health -= 50;
                            }
                        }
                    });

                    createExplosionEffect(explosionPos);
                    Composite.remove(world, currentBird);
                    currentBird = null;
                    break;
            }

            setTimeout(() => {
                if (gameState === 'playing') {
                    loadNextBird();
                }
            }, 1500);
        }

        function createExplosionEffect(pos) {
            // ç®€åŒ–çš„çˆ†ç‚¸æ•ˆæœ - åˆ›å»ºä¸€äº›ç¢ç‰‡
            for (let i = 0; i < 8; i++) {
                const { Bodies, Composite, Body } = Matter;
                const debris = Bodies.circle(
                    pos.x + (Math.random() - 0.5) * 30,
                    pos.y + (Math.random() - 0.5) * 30,
                    3 + Math.random() * 5,
                    {
                        label: 'debris',
                        render: { fillStyle: '#FF4500' },
                        collisionFilter: { category: CATEGORY.DEBRIS }
                    }
                );
                Body.setVelocity(debris, {
                    x: (Math.random() - 0.5) * 15,
                    y: (Math.random() - 0.5) * 15
                });
                Composite.add(world, debris);
            }
        }

        function checkBirdStatus() {
            if (!currentBird) return;

            const { Body } = Matter;
            const speed = Math.sqrt(currentBird.velocity.x ** 2 + currentBird.velocity.y ** 2);

            if (speed < 0.5) {
                // å°é¸Ÿåœæ­¢ï¼Œç§»é™¤å¹¶åŠ è½½ä¸‹ä¸€åª
                Composite.remove(world, currentBird);
                currentBird = null;
                setTimeout(() => {
                    if (gameState === 'playing') {
                        loadNextBird();
                    }
                }, 500);
            } else {
                // ç»§ç»­æ£€æŸ¥
                setTimeout(checkBirdStatus, 500);
            }
        }

        function checkGameEnd() {
            if (pigsRemaining === 0) {
                // èƒœåˆ©
                showGameOver(true);
            } else if (birdsQueue.length === 0 && !currentBird) {
                // å¤±è´¥
                showGameOver(false);
            }
        }

        // ==================== ç¢°æ’å¤„ç† ====================
        function handleCollision(event) {
            const { Vector, Composite, Body } = Matter;

            event.pairs.forEach(pair => {
                const bodyA = pair.bodyA;
                const bodyB = pair.bodyB;

                // è®¡ç®—ç¢°æ’åŠ›åº¦
                const relVel = Vector.sub(bodyA.velocity, bodyB.velocity);
                const impactSpeed = Vector.magnitude(relVel);

                if (impactSpeed < CONFIG.damageThreshold) return;

                // å¤„ç†å°çŒªå—ä¼¤
                [bodyA, bodyB].forEach(body => {
                    if (body.label === 'pig' && body.health !== undefined) {
                        const damage = (impactSpeed - CONFIG.damageThreshold) * CONFIG.damageMultiplier;
                        body.health -= damage;

                        if (body.health <= 0) {
                            // å°çŒªæ­»äº¡
                            removePig(body);
                        }
                    }

                    // å¤„ç†å»ºç­‘ç‰©å—ä¼¤
                    if (body.label === 'block' && body.health !== undefined) {
                        const damage = (impactSpeed - CONFIG.damageThreshold) * CONFIG.damageMultiplier;
                        body.health -= damage;

                        if (body.health <= 0) {
                            // æ–¹å—é”€æ¯
                            removeBlock(body);
                        }
                    }
                });
            });
        }

        function removePig(pig) {
            const { Composite, Bodies, Body, Vector } = Matter;

            // ä»æ•°ç»„ä¸­ç§»é™¤
            const index = pigs.indexOf(pig);
            if (index > -1) {
                pigs.splice(index, 1);
                pigsRemaining--;
                score += pig.pigType.score;
            }

            // åˆ›å»ºç¢ç‰‡æ•ˆæœ
            for (let i = 0; i < 5; i++) {
                const piece = Bodies.circle(
                    pig.position.x + (Math.random() - 0.5) * 20,
                    pig.position.y + (Math.random() - 0.5) * 20,
                    4,
                    {
                        render: { fillStyle: pig.pigType.color },
                        collisionFilter: { category: CATEGORY.DEBRIS }
                    }
                );
                Body.setVelocity(piece, {
                    x: (Math.random() - 0.5) * 8,
                    y: (Math.random() - 0.5) * 8 - 3
                });
                Composite.add(world, piece);
            }

            // ç§»é™¤å°çŒª
            Composite.remove(world, pig);

            updateUI();

            // æ£€æŸ¥æ˜¯å¦å…¨éƒ¨æ¶ˆç­
            if (pigsRemaining === 0) {
                setTimeout(() => showGameOver(true), 1000);
            }
        }

        function removeBlock(block) {
            const { Composite, Bodies, Body } = Matter;

            // ä»æ•°ç»„ä¸­ç§»é™¤
            const index = blocks.indexOf(block);
            if (index > -1) {
                blocks.splice(index, 1);
                score += block.material.score;
            }

            // åˆ›å»ºç¢ç‰‡
            for (let i = 0; i < 3; i++) {
                const piece = Bodies.rectangle(
                    block.position.x + (Math.random() - 0.5) * 20,
                    block.position.y + (Math.random() - 0.5) * 20,
                    8,
                    8,
                    {
                        render: { fillStyle: block.material.color },
                        collisionFilter: { category: CATEGORY.DEBRIS }
                    }
                );
                Body.setVelocity(piece, {
                    x: (Math.random() - 0.5) * 6,
                    y: (Math.random() - 0.5) * 6 - 2
                });
                Composite.add(world, piece);
            }

            // ç§»é™¤æ–¹å—
            Composite.remove(world, block);

            updateUI();
        }

        // ==================== æ¸²æŸ“ ====================
        function beforeRender() {
            const ctx = render.context;
            const { Vector } = Matter;

            // ç»˜åˆ¶èƒŒæ™¯
            ctx.fillStyle = '#87CEEB';
            ctx.fillRect(0, 0, CONFIG.canvasWidth, 200);

            // ç»˜åˆ¶è‰åœ°
            ctx.fillStyle = '#90EE90';
            ctx.fillRect(0, CONFIG.groundY, CONFIG.canvasWidth, CONFIG.canvasHeight - CONFIG.groundY);
        }

        function afterRender() {
            const ctx = render.context;
            const { Vector } = Matter;

            // ç»˜åˆ¶å¼¹å¼“
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(CONFIG.slingshotX - 8, CONFIG.slingshotY - 60, 16, 80);

            // ç»˜åˆ¶å¼¹å¼“çš®ç­‹
            if (currentBird && slingConstraint) {
                ctx.beginPath();
                ctx.moveTo(CONFIG.slingshotX - 8, CONFIG.slingshotY - 40);
                ctx.lineTo(currentBird.position.x, currentBird.position.y);
                ctx.lineTo(CONFIG.slingshotX + 8, CONFIG.slingshotY - 40);
                ctx.strokeStyle = '#8B0000';
                ctx.lineWidth = 4;
                ctx.stroke();
            }

            // ç»˜åˆ¶è½¨è¿¹é¢„è§ˆ
            if (currentBird && slingConstraint && !isBirdFlying) {
                drawTrajectory(ctx);
            }

            // ç»˜åˆ¶å°é¸Ÿ
            if (currentBird) {
                drawBird(ctx, currentBird);
            }

            // ç»˜åˆ¶å°çŒª
            pigs.forEach(pig => {
                drawPig(ctx, pig);
            });

            // ç»˜åˆ¶æ–¹å—
            blocks.forEach(block => {
                drawBlock(ctx, block);
            });
        }

        function drawBird(ctx, bird) {
            const { birdType, birdData } = bird;

            ctx.beginPath();
            ctx.arc(bird.position.x, bird.position.y, birdData.radius, 0, Math.PI * 2);
            ctx.fillStyle = birdData.color;
            ctx.fill();
            ctx.strokeStyle = birdData.borderColor;
            ctx.lineWidth = 3;
            ctx.stroke();

            // ç»˜åˆ¶çœ¼ç›
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(bird.position.x + 5, bird.position.y - 3, 5, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = 'black';
            ctx.beginPath();
            ctx.arc(bird.position.x + 7, bird.position.y - 3, 2, 0, Math.PI * 2);
            ctx.fill();

            // ç»˜åˆ¶çœ‰æ¯›ï¼ˆæ„¤æ€’è¡¨æƒ…ï¼‰
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(bird.position.x - 2, bird.position.y - 10);
            ctx.lineTo(bird.position.x + 5, bird.position.y - 8);
            ctx.stroke();

            // ç»˜åˆ¶å–™
            ctx.fillStyle = '#FFA500';
            ctx.beginPath();
            ctx.moveTo(bird.position.x + 10, bird.position.y + 2);
            ctx.lineTo(bird.position.x + 18, bird.position.y + 5);
            ctx.lineTo(bird.position.x + 10, bird.position.y + 8);
            ctx.closePath();
            ctx.fill();
        }

        function drawPig(ctx, pig) {
            const { pigType, health, maxHealth } = pig;

            ctx.beginPath();
            ctx.arc(pig.position.x, pig.position.y, pigType.radius, 0, Math.PI * 2);
            ctx.fillStyle = pigType.color;
            ctx.fill();
            ctx.strokeStyle = pigType.borderColor;
            ctx.lineWidth = 3;
            ctx.stroke();

            // ç»˜åˆ¶çœ¼ç›
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(pig.position.x - 6, pig.position.y - 4, 5, 0, Math.PI * 2);
            ctx.arc(pig.position.x + 6, pig.position.y - 4, 5, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = 'black';
            ctx.beginPath();
            ctx.arc(pig.position.x - 5, pig.position.y - 3, 2, 0, Math.PI * 2);
            ctx.arc(pig.position.x + 7, pig.position.y - 3, 2, 0, Math.PI * 2);
            ctx.fill();

            // ç»˜åˆ¶é¼»å­
            ctx.fillStyle = '#90EE90';
            ctx.beginPath();
            ctx.ellipse(pig.position.x, pig.position.y + 4, 6, 4, 0, 0, Math.PI * 2);
            ctx.fill();

            // ç»˜åˆ¶è€³æœµ
            ctx.fillStyle = pigType.color;
            ctx.beginPath();
            ctx.ellipse(pig.position.x - 10, pig.position.y - 12, 4, 6, -0.3, 0, Math.PI * 2);
            ctx.ellipse(pig.position.x + 10, pig.position.y - 12, 4, 6, 0.3, 0, Math.PI * 2);
            ctx.fill();

            // è¡€é‡æŒ‡ç¤º
            if (health < maxHealth) {
                const healthPercent = health / maxHealth;
                ctx.fillStyle = 'red';
                ctx.fillRect(pig.position.x - 15, pig.position.y - pigType.radius - 10, 30, 4);
                ctx.fillStyle = '#00FF00';
                ctx.fillRect(pig.position.x - 15, pig.position.y - pigType.radius - 10, 30 * healthPercent, 4);
            }
        }

        function drawBlock(ctx, block) {
            const { material, health, maxHealth, vertices } = block;

            ctx.beginPath();
            ctx.moveTo(vertices[0].x, vertices[0].y);
            for (let i = 1; i < vertices.length; i++) {
                ctx.lineTo(vertices[i].x, vertices[i].y);
            }
            ctx.closePath();
            ctx.fillStyle = material.color;
            ctx.fill();
            ctx.strokeStyle = material.borderColor;
            ctx.lineWidth = 2;
            ctx.stroke();

            // æŸåæ•ˆæœ
            if (health < maxHealth * 0.7) {
                ctx.strokeStyle = 'rgba(0,0,0,0.3)';
                ctx.lineWidth = 1;
                for (let i = 0; i < 3; i++) {
                    const x = block.position.x + (Math.random() - 0.5) * 30;
                    const y = block.position.y + (Math.random() - 0.5) * 30;
                    ctx.beginPath();
                    ctx.moveTo(x - 5, y - 5);
                    ctx.lineTo(x + 5, y + 5);
                    ctx.moveTo(x + 5, y - 5);
                    ctx.lineTo(x - 5, y + 5);
                    ctx.stroke();
                }
            }
        }

        function drawTrajectory(ctx) {
            const { Vector, Body } = Matter;

            const anchor = { x: CONFIG.slingshotX, y: CONFIG.slingshotY };
            const pullVector = Vector.sub(anchor, currentBird.position);
            const pullDistance = Math.min(Vector.magnitude(pullVector), CONFIG.maxPullDistance);

            if (pullDistance < 20) return;

            const direction = Vector.normalise(pullVector);
            const force = pullDistance * CONFIG.launchForceMultiplier;
            const velocity = Vector.mult(direction, force * 1000);

            ctx.fillStyle = 'rgba(255,255,255,0.6)';

            for (let t = 0; t < 30; t++) {
                const x = currentBird.position.x + velocity.x * t * 0.05;
                const y = currentBird.position.y + velocity.y * t * 0.05 + 0.5 * CONFIG.gravity.y * 500 * (t * 0.05) * (t * 0.05);

                if (y > CONFIG.groundY || x > CONFIG.canvasWidth || x < 0) break;

                const alpha = 1 - t / 30;
                ctx.fillStyle = `rgba(255,255,255,${alpha * 0.6})`;
                ctx.beginPath();
                ctx.arc(x, y, 4, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // ==================== UI æ›´æ–° ====================
        function updateUI() {
            document.getElementById('scoreValue').textContent = score;

            // æ˜¾ç¤ºå‰©ä½™å°é¸Ÿ
            const birdsDisplay = document.getElementById('birdsDisplay');
            let birdIcons = '';

            // å·²ä½¿ç”¨çš„
            for (let i = 0; i < usedBirds; i++) {
                birdIcons += '<div class="bird-icon" style="background: #888;"></div>';
            }

            // å½“å‰å°é¸Ÿ
            if (currentBird) {
                birdIcons += `<div class="bird-icon" style="background: ${currentBird.birdData.color}; border-color: ${currentBird.birdData.borderColor};"></div>`;
            }

            // å¾…ä½¿ç”¨
            birdsQueue.forEach(type => {
                birdIcons += `<div class="bird-icon" style="background: ${BIRD_TYPES[type].color}; border-color: ${BIRD_TYPES[type].borderColor};"></div>`;
            });

            birdsDisplay.innerHTML = birdIcons;
        }

        // ==================== æ¸¸æˆç»“æŸ ====================
        function showGameOver(won) {
            const level = LEVELS[currentLevel];
            const thresholds = level.starThresholds;

            let stars = 0;
            if (won) {
                // è®¡ç®—æ˜Ÿçº§
                if (score >= thresholds.threeStars) stars = 3;
                else if (score >= thresholds.twoStars) stars = 2;
                else if (score >= thresholds.oneStar) stars = 1;

                // ä¿å­˜è¿›åº¦
                if (stars > levelStars[currentLevel]) {
                    levelStars[currentLevel] = stars;
                    saveProgress();
                }
            }

            // æ˜¾ç¤ºå¼¹çª—
            const modal = document.getElementById('gameOverModal');
            document.getElementById('modalTitle').textContent = won ? 'ğŸ‰ è¿‡å…³å•¦ï¼' : 'ğŸ’” æ¸¸æˆç»“æŸ';
            document.getElementById('modalStars').textContent = won ? 'â­'.repeat(stars) : 'ğŸ’”';
            document.getElementById('finalScore').textContent = score;
            document.getElementById('modalMessage').textContent = won
                ? `ä½¿ç”¨ ${usedBirds} åªå°é¸Ÿï¼Œè·å¾— ${stars} æ˜Ÿè¯„ä»·ï¼`
                : 'å°çŒªè¿˜æ²¡æœ‰å…¨éƒ¨æ¶ˆç­ï¼Œå†è¯•ä¸€æ¬¡å§ï¼';

            // ä¸‹ä¸€å…³æŒ‰é’®
            const nextBtn = document.getElementById('nextLevelBtn');
            nextBtn.style.display = (won && currentLevel < LEVELS.length - 1) ? 'block' : 'none';

            modal.classList.add('active');
        }

        function hideGameOver() {
            document.getElementById('gameOverModal').classList.remove('active');
        }

        function restartLevel() {
            hideGameOver();
            startLevel(currentLevel);
        }

        function backToLevelSelect() {
            hideGameOver();
            showLevelSelect();
        }

        function nextLevel() {
            hideGameOver();
            if (currentLevel < LEVELS.length - 1) {
                startLevel(currentLevel + 1);
            }
        }

        // ==================== æ•°æ®æŒä¹…åŒ– ====================
        function saveProgress() {
            localStorage.setItem('angryBirdsStars', JSON.stringify(levelStars));
        }

        function loadProgress() {
            const saved = localStorage.getItem('angryBirdsStars');
            if (saved) {
                levelStars = JSON.parse(saved);
            }
        }

        // ==================== å·¥å…·å‡½æ•° ====================
        function goBackHome() {
            hideGameOver();
            gameState = 'menu';
            showMenu();
            window.location.href = '../../index.html';
        }

        // ==================== å¯åŠ¨æ¸¸æˆ ====================
        window.onload = init;
    </script>
</body>
</html>
